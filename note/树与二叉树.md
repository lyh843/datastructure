# 树与二叉树

## 一、树和森林的概念

### 树的基本术语

- **根(root)：**一个只有直接后继，但没有直接前驱的结点。
- **根的子树：**根以外的其他结点划分为$m(m\geq 0)$个互不相交的有限集合$T_1, T_2, \dots, T_m$，每个集合又是一棵树。
- **子女结点：**若结点的子树非空，结点子树的根即为该结点的子女。
- **父结点：**若结点有子女，该结点是子女双亲。
- **兄弟结点：**同一结点的子女互称为兄弟。
- **度：**结点的**子女个数**即为该结点的度；树中各个结点的**度的最大值**称为**树的度**。
- **叶结点：**度为0的结点即为叶结点，亦称为终端结点。
- **分支结点：**度不为0的结点即为分支结点，亦称为非叶结点。
- **祖先结点：**某结点到根结点的路径上的各个结点都是该结点的祖先。
- **子孙结点：**某结点的**所有下属结点**，都是该结点的子孙。
- **结点的层次：**规定**根结点在第一层**，其子女结点的层次等于它的层次加一

- **深度：**结点的深度即为结点的层次；**离根最远结点的层次**即为**树的深度**。

- **高度：**规定**叶结点的高度为1**，其父结点的高度等于它的高度加一。 
- **树的高度：**等于根结点的高度，即根结点所有子女高度的**最大值加一。**
- **有序树：**树中结点的各棵子树 $T_0, T_1, \dots$ 是有次序的，即为有序树。
- **无序树：**树中结点的各棵子树之间的次序是不重要的，可以互相交换位置。
- **森林：**森林是 $m(m \geq 0)$ 棵树的集合

## 二、二叉树

### 性质

1. 若二叉树的节点的层次从1开始，则在**二叉树的第$i$层最多有$2^{i-1}$个结点**。$(i \geq 1)$

2. 深度为**k**的二叉树最少有**k**个结点，最多有$2^k-1$个结点。

   > 二叉树的每层最少1个结点，最多$2^{i - 1}$个节点。
   >
   > 对等比数列求和可得：$2^0 + 2^1 +\cdots + 2^{k-1} = 2^k - 1$

3. 对任何一棵二叉树，如果其叶结点有$n_0$个, 度为 $2$ 的非叶结点有$n_2$个,   则有 $n_0 = n_2 + 1$.

   > 若设度为1的节点有$n_1$个，总结点数为$n$，总边树为$e$，根据二叉树的定义：
   > $$
   > n = n_0 + n_1 + n_2 \quad e = 2n_2 + n_1 = n - 1.
   > $$
   > 因此，有$2n_2 + n_1 = n_0 + n_1 + n_2 - 1 \Rightarrow n_2 = n_0 - 1$.

4. 具有$n(n\geq 0)$个结点的完全二叉树的深度为$\lceil \log_2(n+1)\rceil$

   > 设完全二叉树的深度为$k$，则有$2^{k-1} -1< n \leq 2^k -1$，
   >
   > 变形成$2^{k-1} < n + 1 \leq 2^k$，取对数：$k - 1 < \log_2(n+1) \leq k$
   >
   > 有$\lceil \log_2(n+1) \rceil = k$

5. 如果将一棵有$n$个结点的完全二叉树**自顶向上**，**同一层自左向右**连续给结点编号$1, 2, \dots, n$，则有以下关系：

   - 若$i = 1$，则$i$无父节点
   - 若$i > 1$，则$i$的父节点为$\lfloor \frac{i}{2} \rfloor$
   - 若$2 * i \leq n$，则$i$的左子女为$2*i$
   - 若$2*i + 1 \leq n$，则$i$的右子女为$2*i + 1$
   - 若$i$为奇数，且$i \neq 1$，则其左兄弟为$i-1$
   - 若$i$为偶数，且$i \neq n$，则其右兄弟为$i + 1$

6. 完全二叉树的**总结点数与叶子结点数量**的关系：$n_0 = \lceil \frac{n}{2} \rceil$.

   > 因为$n_0 + n_1 + n_2 = 100$，且$n_0 = n_2 + 1$.
   >
   > 对于完全二叉树有$n_1 = 0 or 1$.
   >
   > 因此$n_0 = \lceil \frac{n}{2} \rceil$.

### 定义

1. **满二叉树（FULL Binary Tree）：**一颗深度为$k$且拥有$2^k-1$个结点的二叉树。

2. **完全二叉树（Complete Binary Tree）:**一颗深度为$k$且除第$k$层外，其他各层$(1 \sim k- 1)$的结点数都达到了最大个数，第$k$层**从右向左连续缺若干节点**，这就是完全二叉树。

   > 度数为1的结点只有0或1个。

### 链表表示

#### 1. 二叉链表

每个结点有3个数据成员，`data`域存储结点数据，`left_child`和`right_child`分别存放指向左右子女的指针。

#### 2. 三叉链表

相比二叉链表，每个结点增加一个指向双亲的指针`parent`指向父母节点。

**静态结构：**

|      | `data` | `parent` | `left_child` | `right_child` |
| ---- | ------ | -------- | ------------ | ------------- |
| 0    | A      | -1       | 1            | -1            |
| 1    | B      | 0        | 2            | 3             |
| 2    | C      | 1        | -1           | -1            |
| 3    | D      | 1        | 4            | 5             |
| 4    | E      | 3        | -1           | -1            |
| 5    | F      | 3        | -1           | -1            |

## 三、二叉树遍历

设访问根结点记作`V`，遍历根的左子树记作`L`，遍历根的右子树记作`R`。

可能得遍历次序有：

- 前序：`VLR`
- 中序：`LVR`
- 后序：`LRV`

### 中序遍历（Inorder Traversal）

#### 框架：

- 若二叉树为空，则空操作；
- 否则
  - 中序遍历左子树（L）；
  - 访问根结点（V）;
  - 中序遍历右子树（R）。

#### 代码实现：

```cpp


```

### 前序遍历（Preorder Traversal）

#### 框架：

- 若二叉树为空，则空操作；
- 否则
  - 访问根结点（V）；
  - 前序遍历左子树（L）；
  - 前序遍历右子树（R）。

### 后序遍历（Postorder Traversal）

#### 框架：

- 若二叉树为空，则空操作；
- 否则
  - 后序遍历左子树（L）；
  - 后序遍历右子树（R）；
  - 访问根节点（V）。

## 四、线索化二叉树

通过事先处理，将某种遍历顺序下的前驱、后继关系记在树的存储结构中，以后就可以高效地找出某结点的前驱、后继。

### 中序化线索二叉树

1. **后继：**
   - `current->rtag == 1`：后继为`current->right_child`
   - 后继为：当前结点右子树的中序下的第一个节点。
2. **前驱：**
   - `current->ltag == 1`：前驱为`current->left_child`
   - 前驱为：当前结点左子树中序下的最后一个结点。

### 前序化线索二叉树

1. 

## 五、树与森林

### 1. 树的存储表示

1. 广义表表示：

   $A(B(E, F),C, D(G))$

2. 双亲表示：

   按照树的**前序次序**进行存放，并且存它的`parent`

3. 子女链表表示：

   有序树必须自左向右链接各个子女结点。

4. 子女指针表示：

   在结点中存放指向每一个子女结点的指针。

   每个结点包含的指针个数相等，等于树的度。

5. 子女-兄弟表示：

   `data. firstChild, nextSibling`

### 2. 森林转化为二叉树的规则

1. 若$F$为空，即$n = 0$，则对应的二叉树$B$为空树
2. 若$F$不空，则
   - 二叉树$B$的根是$F$的一棵树$T_1$的根
   - 其左子树为$B(T_{11}, T_{12}, \cdots, T_{1m})$，其中，$T_{11}, T_{12}, \cdots, T_{1m}$是$T_1$的根的子树
   - 其右子树为$B(T_2, T_3, \cdots, T_n)$，其中，$T_2, T_3, \cdots, T_n$是除$T_1$外其他树构成的森林

### 3. 二叉树转化为森林的规则



### 4.树的遍历

#### 1. 深度优先

- 先根次序遍历
  - 与对应二叉树表示的前序遍历结果相同
- 后根次序遍历
  - 与对应二叉树表示的中序遍历结果相同

#### 2. 广度优先遍历

```cpp
template <class T>
void Tree<T>::
LevelOrder(void (*visit)(BinTreeNode<T> *t)){
    Queue<TreeNode<T>*>Q;
    TreeNode<T>*p;
    if(current != NULL){
        p = current;
        Q.EnQueue(current);
        while(!Q.IsEmpty()){
            Q.DeQueue(current);
            visit(current);
        }
    }
}
```



## 六、堆（Heap）





## 七、Huffman 树