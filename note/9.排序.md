# 第九章 排序

## 一、概述

### 1. 基本概念

- **数据表（datalist）**：待排序数据元素的有限集合。
- **排序码（key）**：用于区分元素、作为排序依据的属性域，选择需结合具体应用场景。

### 2. 排序算法关键评价指标

| 评价维度    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| 稳定性      | 若排序前`r[i]`与`r[j]`**排序码相等**且`r[i]`在前者，排序后仍保持该顺序，则算法稳定；否则不稳定 |
| 内 / 外排序 | 内排序：排序期间所有数据存于内存；外排序：数据量过大，需在内外存间移动 |
| 时间开销    | 核心衡量标准，用排序码**比较次数**和元素**移动次数**评估，需考虑最好、最坏、平均情况 |
| 空间开销    | 算法执行所需的附加存储容量                                   |

## 二、插入排序(Insert Sorting)

每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上，直到元素全部插入为止。

---

### 1. 直接插入(Insert Sort)

#### 基本思想

第`i`趟插入时，前面`V[0]~V[i-1]`已有序，将`V[i]`按排序码顺序与前序元素比较，插入合适位置，原位置元素后移。

#### 算法分析

**时间开销：**

- **最坏情况：**第$i$趟时第$i + 1$个元素必须与前面$i$个元素进行比较，并且做$i$次移动。则：

$$
KCN = \sum_{i = 1}^{n - 1}i = \frac{n(n - 1)}{2} \approx \frac{n^2}{2}\\
RMN = \sum_{i = 1}^{n - 1}(i + 2) = \frac{(n + 4)(n - 1)}{2} \approx \frac{n^2}{2}
$$

其中$KCN$为总排序码比较次数，$RMN$为元素移动次数。

- **最好情况：**每趟只需与前面有序元素序列的最后一个元素比较1次，此时$KCN = n - 1$，$RMN = 0$.

平均情况下的时间复杂度为$O(n^2)$

**稳定性：**稳定

**附加存储：**$O(1)$

---

### 2. 折半插入

#### 基本思想

第`i`趟插入时，前面`V[0]~V[i-1]`已有序，将`V[i]`利用**折半搜索法**与前序元素比较，插入合适位置，原位置元素后移。

#### 算法分析

**时间开销：**

- **最坏情况：**插入第$i$个元素时，需要经过$\lfloor \log_2i \rfloor + 1$次比较，插入合适位置，原位置元素后移。

$$
KCN = \sum_i^{n - 1}(\lfloor \log_2 i \rfloor + 1) \approx n \cdot \log_2 n
$$

- **最好情况：**当初始排列已经排好序或接近有序时，会比直接插入排序慢。

**稳定性：**稳定

**附加存储：**$O(1)$

---

### 3. Shell排序（缩小增量排序）

#### 基本思想

1. 设待排序元素序列有$n$个元素，首先取一个整数$gap < n$作为间隔，将全部元素分为$gap$个子序列，所有距离为$gap$的元素放在同一个子序列中。
2. 每一个子序列中分别施行**直接插入排序**。
3. 然后缩小间隔$gap$，例如取$gap = \lceil gap / 2 \rceil$，重复上述的子序列划分和排序工作。直到最后取$gap == 1$，将所有元素放在同一个序列中排序为止。

#### 算法分析

**时间开销：**介于$n^{1.25}$到$1.6n^{1.25}$的范围内

**稳定性：**不稳定

**附加存储：**$O(1)$

---

## 三、交换排序

### 1. 冒泡排序(Bubble Sort)

#### 基本思想

最多执行`n-1`趟，第`i`趟前向后两两比较`V[j-1]`与`V[j]`，逆序则交换，每趟将当前最大元素 “冒泡” 至后端。

#### 算法分析

**时间开销：**

- **最坏情况：** 算法执行$n - 1$趟冒泡，第$i$趟做$n - i$次排序码比较。执行$n - i$次元素交换。
  $$
  KCN = \sum_{i = 1}^{n - 1} (n - i) = \frac{n(n - 1)}{2}\\
  RMN = 3\sum_{i = 1}^{n - 1} (n - i) = \frac{3n(n - 1)}{2}
  $$

- **最好情况：**算法只执行一趟冒泡，做$n - 1$次排序码比较，不移动元素。

**稳定性：**稳定

**附加存储：**一个附加元素实现元素值对换

#### 代码实现

```cpp
#define NUM 100
int arr[NUM];
bool exchange = true;
for(int i = 0; i < NUM - 1 && exchange; i++){
    exchange = false;
    for(int j = 0; j < NUM - i - 1; j++){
        if(arr[j] > arr[j +1]){
            exchange = true;
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

---

### 2. 快速排序（Quick Sort）

#### 基本思想

任取待排序元素序列中的某个元素作为基准，按照该元素的排序码大小，将整个元素序列划分为左右两个子序列：

- 左侧子序列中所有元素的排序码都**小于或等于**基准元素的排序码
- 右侧子序列中所有元素的排序码都**大于**基准元素的排序码

基准元素则排在这两个子序列中间（这也是该元素最终应安放的位置）

然后分别对这两个子序列重复施行上述方法，直到所有的元素都排在相应位置上为止。

多种不同的方案：**前后指针法**和**挖坑法**

#### 前后指针法

```cpp
void QuickSort(dataList &L, const int left, const int right){
    if(left < right){
        int pivotpos = L.Partition(left, right);
        QuickSort(L, left, pivotpos - 1);
        QuickSort(L, pivotpos + 1, right);
    }
}

int Partition(const int low, const int high){
    int pivotpos = low;
    Element pivot = Vector[low];	// 基准元素
    for(iny i = low + 1; i <= high; i++){
        if(Vector[i] < pivot){
            pivotpos++;
            if(pivotpos != i){
                Swap(Vector[pivotpos], Vector[i]);
            }	// 小于基准元素的交换到左边去
        }
        Vector[low] = Vector[pivotpos];
        Vector[pivotpos] = pivot;	// 将基准元素就位
        return pivotpos;
    }
}
```

#### 挖坑法

```cpp
int Partition_Classic(int s, int t){
    int pivot = a[s], i = s, j = t;
    while(i < j){
        while((i < j) && (a[j] >= pivot)) j = j - 1;
        if(i < j){
            a[i] = a[j];
            i = i + 1;
        }
        
        while((i < j) && (a[i] <= pivot)) i = i + 1;
        if(i < j){
            a[j] = a[i];
            j = j - 1;
        }
    }
    a[i] = pivot;
    return i;
}
```

#### 算法分析

算法quickSort是一个递归算法，快速排序的趟数取决于递归树的高度。

最大递归调用层数与递归树高度一致，**理想情况**为$\lceil \log_2(n + 1) \rceil$

**存储开销**为$O(\log_2 n)$

**最坏情况：**排序元素序列已经按照排序码从小到大排好序的情况下，递归树成为单支树。必须经过$n - 1$趟才能把所有元素定位，而且第$i$趟需要经过$n - i$次排序码比较才能找到第$i$个元素的位置，为$O(n^2)$

#### Randomized QuickSort

对于每个待排序的数组（子数组），在划分前，先执行以下步骤：

1. 生成一个从$1 \sim n$的随机数
2. 交换`A[1]`和`A[r]`

---

## 四、选择排序

### 1. 直接选择排序（Select Sort）

#### 基本思想

1. 在一组元素$v[i] \sim v[n - 1]$中选择具有最小排序码的元素；
2. 若它不是这组元素中的第一个元素，则将它与这组元素中的第一个元素对调。
3. 在这组元素中剔除这个具有最小排序码的元素。在剩下的元素$v[i + 1] \sim v[n - 1]$中重复执行第1、2步，直到剩余元素只有一个为止。

#### 代码实现

```cpp
void SelectSort(datalist& L, const int left, const int right){
    for(int i = left; i < right; i++){
        int k = i;
        for(int j = i + 1; j <= right; j++){
            if(L[j] < L[k]) k = j;
        }
        if(k != i) Swap(L[i], L[k]);
    }
}
```

#### 算法分析

设整个待排序元素序列有$n$个元素，则第$i$趟选择具有最小排序码元素所需的比较次数总是$n - i - 1$次，总的**排序码比较次数**为
$$
KCN = \sum_{i = 0}^{n - 2} (n - i - 1) = \frac{n(n - 1)}{2}
$$
元素移动次数与元素序列初始排序有关：

- 当初始状态按排序码从小到大有序时，只比较不移动：$RMN = 0$
- **最坏情况下：** 每一趟都要进行交换，总元素移动次数：$RMN = 3(n - 1)$

**稳定性：**不稳定

---

### 2. 竞标赛排序（Tournament Tree Sort）

#### 基本思想

- 首先取得 n个元素的排序码，进行两两比较，得到$\lceil \frac{n}{2} \rceil$个比较的优胜者(排序码小者)，作为第一步比较的结果保留下来。
- 然后对这$\lceil \frac{n}{2} \rceil$个元素再进行排序码的两两比较，……，如此重复，直到选出一个排序码最小的元素为止。

#### 算法分析

胜者树是完全二叉树，其高度为$\lceil \log_2 n \rceil$，其中$n$为待排序元素个数

除第一次选择具有最小排序码的元素需要 进行$n - 1$次排序码比较外, 重构胜者树选择次小、再次小排序码**所需的比较次数**均为$O(\log_2 n)$。**总排序码比较次数**为$O(n\log_2 n)$。

**稳定性：**稳定

**额外存储：**$2n - 1$个结点来存放胜者树

---

### 3. 堆排序（Heap Sort）

#### 基本思想

- 利用堆及其运算，可以很容易地实现选择排序的思路。
- 堆排序分为两个步骤：
  - 根据初始输入数据，利用堆的调整算法`siftDown()​`形成初始堆
  - 通过一系列的元素交换和重新调整堆进行排序

- 为了实现元素按排序码从小到大排序，要求建立**最大堆**。

#### 基本步骤

- 最大堆堆顶`L.Vector[0]`具有最大的排序码，将`L.Vector[0]`与`L.Vector[n-1]`对调，把具有最大排序码的元素交换到最后，再对前面的`n-1`个元素，使用堆的调整算法`siftDown(L, 0, n-2)`，重新建立最大堆，具有次最大排序码的元素又上浮到`L.Vector[0]`位置。 
- 再对调`L.Vector[0]`和`L.Vector[n-2]`，再调用`siftDown(L, 0, n-3)`，对前面的`n-2`个元素重新调整。

#### 代码实现

```cpp
void HeapSort(datalist& L){
    int n = L.length();
    for(int i = (n - 2) / 2; i >= 0; i--) siftDown(L, i, n - i);
    for(int i = n - 1; i >= 1; i--){
        L.Swap(0, i);
        siftDown(L, 0, i - 1);
    }
}
```

#### 算法分析

第二个`for`循环调用了$n - 1$次`siftDown()`算法，因此整体**时间复杂度为$O(n \log_2 n)$**

**附加存储：**$O(1)$

**稳定性：**不稳定

## 五、归并排序（Merge Sort）——二路归并（2-way merging）

**归并**：将两个或两个以上的有序表合并成一个新的有序表。

### 1. 迭代二路归并

#### 基本思想

- 设初始元素序列有$n$个元素，首先把它看成是$n$个长度为$1$的有序子序列（归并项），做两两归并，得到$\lceil \frac{n}{2} \rceil$个长度为$2$的归并项（最后一个归并项的长度为$1$）；
- 再做两两归并，得到$\lceil \frac{n}{4} \rceil$个长度为$4$的归并项（最后一个归并项长度可以短些），……
- 如此重复，最后得到一个长度为 n 的有序序列。

#### 代码实现

**两路归并算法：**

```cpp
void merge(datalist& L1, datalist& L2, const int left, const int mid, const int right){
    int k, i, j;
    i = left; j = mid + 1; k = left;
    while(i <= mid && j <= right){
        if(L1[i] <= L1[j]) 
            L2[k++] = L1[i++];
        else 
            L2[k++] = L1[j++];
    }
    while(i <= mid) L2[k++] = L1[i++];
    while(j <= right) L2[k++] = L1[j++];
}
```

**一趟归并排序算法：**

```cpp
void MergePass(datalist& L1, datalist& L2, const int len){
    int i = 0, j, n = L1.Length();
    while(i + 2 * len <= n - 1){
        merge(L1, L2, i, i + len - 1, i + 2 * len - 1);
        i += 2 * len;
    }
    if(i + len <= n - 1)
        merge(L1, L2, i, i + len - 1, n - 1);
    else for(j = i; j <= n - 1; j++) L2[j] = L1[j];
}
```

**归并排序的主算法：**

```cpp
void MergeSort(datalist& L){
    int n = L.Length();
    datalist templist(n);
    int len = 1;
    while(len < n){
        MergePass(L, tempList, len);
        len *= 2;
        MergePass(tempList, L, len);
        len *= 2;
    }
}
```

#### 算法分析

在迭代的归并排序算法中，函数`MergePass()`做一趟两路归并排序，调用`merge()`函数$\lceil \frac{n}{2 \times len} \rceil \approx O(n/len)$次，函数`MergeSort()`调用`MergePass()`正好$\lceil \log_2 n \rceil$次，而每次`merge()`要执行$O(len)$次，所以**总时间复杂度为**$O(n \log_2 n)$

**附加存储：**一个与原待排序元素数组同样大小的辅助数组

**稳定性：**稳定

### 2. 递归二归并

#### 基本思想

1. 首先, 要把整个待排序序列划分为两个长度大致相等的部分，分别称之为左子表和右子表。

2. 对左、右子表分别递归地进行排序
3. 把排好序的左右两个子表进行归并

#### 代码实现

**静态链表的二路归并算法**

```cpp
int ListMerge(const int start1, const int start2){
    int k = 0, i = start1, j = start2;
    while(i && j){
        if(Vector[i].key <= Vector[j].key){
            Vector[k].link = i;
            k = i;
            i = Vector[i].link;
        }
        else{
            Vector[k].link = j;
            k = j;
            j = Vector[j].link;
        }
        if(i == 0) Vector[k].link = j;
        else Vector[k].link = i;
        return Vector[0].link;;
    }
}
```

**递归的归并排序算法**

```cpp
int MergeSort(const int left, const int right){
    if(left >= right) return left;
    int mid = (left + right) / 2;
    return ListMerge(MergeSort(left, mid), MergeSort(mid + 1, right))
}
```

#### 算法分析

**递归深度为：**$O(\log_2 n)$

**比较次数为：**$O(n\log_2n)$

**稳定性：**稳定

## 附录：排序的性能分析

| 排序方法 | 比较次数 | 比较次数 | 移动次数 | 移动次数 | 稳定性 | 附加存储 | 附加存储 |
|---------|---------|---------|-------|---------|-------|-------|-------|
|          | 最好 | 最差 | 最好 | 最差 |  | 最好 |最差|
| 直接插入排序 | $n$ | $n^2$ | $0$ | $n^2$ | √ | $1$ |$1$|
| 折半插入排序 | $n\log_2 n$ | $n\log_2n$ | $0$ | $n^2$ | √ | $1$ |$1$|
| 冒泡排序 | $n$ | $n^2$ | $0$ | $n^2$ | √ | $1$ |$1$|
| 快速排序 | $n \log_2n$ | $n^2$ | $< n \log_2n$ | $n^2$ | × | $\log_2n$ | $n$ |
| 简单选择排序 | $n^2$ | $n^2$ | $0$ | $n$ | × | $1$ |$1$|
| 锦标赛排序 | $n \log_2n$ | - | - | - | √ | n ||
| 堆排序 | n log₂n | - | - | - | × | 1 ||
| 归并排序 | n log₂n | - | - | - | √ | n ||

