# 第七章——搜索结构

## 一、静态搜索结构

**搜索：**在数据集合中寻找满足某种条件的数据对象

**搜索结构：**用于搜索的数据集合，由同一数据类型的对象组成

**搜索表：**

- **静态搜索表：**搜索结构在插入和删除等操作的前后不发生改变
- **动态搜索表：**为保持较高的搜索效率，搜索结构在插入和删除等操作的前后将自动进行调整，结构可能发生变化

### 静态搜索表

#### 顺序搜索（Sequential Search）

顺序搜索主要用于在线性表中搜索，从表的先端开始搜索，直至找到或检测完成。

**监视哨：**将尾部的空节点赋值为目标值。

#### 二分搜索

搜索表需要是有序的。

## 二、二叉搜索树

### 定义

二叉搜索树是一棵空树，或者是具有下列性质的二叉树：

- 每个结点都有一个座位搜索依据的关键码，所有结点的关键码互不相同
- 左子树（如果非空）上所有结点的关键码都小于根节点的关键码
- 右子树（如果非空）上所有结点的关键码都大于根节点的关键码
- 左子树和右子树也是二叉搜索树

如果进行中序遍历，可以实现按从小到大的顺序将各行的关键码排列起来

### 搜索算法

#### 步骤

1. 如果根指针为`NULL`，则搜索不成功；否则给定值`x`与根结点的关键码进行比较：

   - 若给定值等于根结点关键码，

     搜索成功，返回搜索成功信息并报告搜索到的节点。

   - 若给定值小于根结点的关键码，

     继续递归搜索根结点的左子树

   - 否则，

     递归搜索根结点的右子树

#### 代码实现

```cpp
// 递归实现
template<class E, class K>
Search(const K x, BSTNode<E, K>* ptr){
    if(ptr == nullptr) return nullptr;
    else if(x < ptr->data.key) return Search(x, ptr->left);
    else if(x > ptr->data.key) return Search(x, ptr->right);
    else return ptr;
};

// 非递归实现
template<class E, class K>
Search(const K x, BSTNode<E, K>* ptr){
	if(ptr == nullptr) return nullptr;
    while(ptr != nullptr){
        if(x < ptr->data.key) ptr = ptr->left;
        else if(x > ptr->data.key) ptr = ptr->right;
        else return ptr;
    }
    return ptr;
};
```

### 插入算法

### 步骤

在二叉搜素树中插入一个新元素时，必须先检查这个元素是否存在于树中。

在插入前，前

### 删除算法

## 三、AVL树

### 定义

一棵`AVL`树是空树或者是具有以下性质的二叉搜索树：它的左子树和右子树都是`AVL`树，且左子树和右子树的高度之差的绝对值不超过1

**结点的平衡因子（balance factor）**

每个结点附加一个数字，给出该结点右子树的高度减去左子树的高度所得的高度差。这个数字即为结点的平衡因子`bf`

- `AVL`树任一结点平衡因子只能取`-1, 0, 1`

### 平衡化旋转

如果在一棵平衡的二叉搜索树中插入一个新结点，造成了不平衡。此时必须调整数的结构，使之平衡化。

**类型：**

- 单旋转（左旋和右旋）
- 双旋转（左平衡和右平衡）

#### 步骤

每插入一个新结点时，`AVL`树中相关结点的平衡状态会发生改变。因此，插入一个新节点后：

- 从插入位置沿通过根的路径回溯，检查各节点的平衡因子
- 如果某一节点发现高度不平衡，停止回溯，从不平衡的结点起，沿刚才回溯的路径取直接下两层的节点。
  - 如果三个结点处于**一条直线上**，采用单旋转进行平衡化。
  - 如果三个结点处于**一条折线上**，则采用双旋转进行平衡化。