# 第八章 图

## 一、图的基本概念

**图定义：**图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：
$$
\text{Graph} = (V, E)
$$
其中$V = \{x | x \in \text{某个数据对象}\}$是顶点的有穷集合；

$E = \{(x, y) | x, y \in V\}$或$E = \{<x, y> | x, y \in V \&\& Path(x, y)\}$是顶点之间关系的有穷集合，也叫做边(edge)集合；$Path(x, y)$表示从$x$到$y$的一条单向通路，它是有方向的。

**有向图：**顶点对$<x, y>$是有序的

**无向图：**顶点对$(x, y)$是无序的

**完全图：**若有$n$个顶点的无向图有$\frac{n(n - 1)}{2}$条边，则此图为**完全无向图**。有$n$个顶点的有向图有$n(n - 1)$条边，则此图为**完全有向图**。

**邻接顶点：**如果$(u, v)$是$E(G)$中的一条边，则称$u$与$v$互为**邻接顶点**。

**权：** 某些图的边具有与它相关的数, 称之为**权**。这种**带权图叫做网络**。

**顶点的度：** 一个顶点$v$的度是与它相关联的边的条数。记作$\text{TD}(v)$。在有向图中, 顶点的度等于该顶 点的入度与出度之和。

**顶点$v$的入度：**是以$v$为**终点**的有向边的条数, 记作$\text{ID}(v)$

**顶点$v$的出度**：是以$v$为**始点**的有向边的条数，记作$\text{OD}(v)$

**路径：** 在图$G = (V, E)$中，若从顶点$v_i$出发, 沿一 些边经过一些顶点$v_{p_1}, v_{p_2}, \dots, v_{p_m}$，到达顶点$v_j$。 则称顶点序列$(v_i v_{p_1} v_{p_2} \dots v_{p_m} v_j)$为从顶点$v_i$到顶点$v_j$的路径。它经过的边$(v_i, v_{p_1}), (v_{p_1}, v_{p_2}), \dots, (v_{p_m}, v_j)$应是属于$E$的边。

**路径长度：** 非带权图的路径长度是指此路径上边的条数。带权图的路径长度是指路径上各边的权之和。

**简单路径：**若路径上各顶点$v_1, v_2, \dots, v_m$**均不互相重复**，则称这样的路径为简单路径。

**回路：** 若路径上第一个顶点$v_1$与最后一个顶点$v_m$重合，则称这样的路径为**回路或环**。

**连通图与连通分量：**在无向图中，若从顶点$v_1$到顶点$v_2$有路径，则称顶点$v_1$与$v_2$是连通的。如果图中任意一对顶点都是连通的，则称此图是连通图。非连通图的极大连通子图叫做连通分量。

**强连通图与强连通分量：** 在有向图中，若对于每 一对顶点$v_i$和$v_j$，都存在一条从$v_i$到$v_j$和从$v_j$到$v_i$的 路径，则称此图是强连通图。非强连通图的**极大强连通子图**叫做强**连通分量**

**生成树：**一个连通图的生成树是其极小连通子图，在$n$个顶点的情形下，有$n - 1$条边。在生成树中添加一条边之后，必定会形成回路或环。

## 二、图的存储表示

### 邻接矩阵（Adjacency Matrix）

 在图的邻接矩阵表示中，有一个记录各个顶点信息的**顶点表**，还有一个表示各个顶点之间关系的**邻接矩阵**。

- 设图$A = (V, E)$是一个有$n$个顶点的图，图的邻接矩阵是一个二维数组`A.edge[n][n]`，定义：
  $$
  A.edge[i][j] = 
  \begin{cases}
  1, & 如果\ <i, j> \in E \ 或者\ (i, j) \in E\\
  0, & 否则
  \end{cases}
  $$

> 无向图的邻接矩阵是对称的；有向图的邻接矩阵可能是不对称的。

- 在有向图中，统计第$i$行的$1$的个数可得顶点$i$的出度，统计第$j$列的$1$的个数可得顶点$j$的入度。
- 在无向图中，统计第$i$行（列）$1$的个数可得顶点$i$的度。

#### 网络（带权图）的邻接矩阵

$$
A.edge[i][j] = 
\begin{cases}
W(i, j), & 若i \neq j且<i, j> \in E\  或\ (i, j) \in E\\
\infty, & 若i \neq j且<i, j> \notin E \ 或\ (i, j) \notin E\\
0, & 若 i == j
\end{cases}
$$

### 邻接表（Adjacency List）

在邻接表中，同一个顶点发出的边连接在同一个边链表中，每一个链结点代表一条边（边结点），结点中有另一顶点的下标`dest`和指针`link`。对于带权图，边结点中还要保存该边的权值`cost`。

顶点表的第$i$个顶点中保存该顶点的数据，以及它对应边链表的头指针`adj`

- 有向图存在**邻接表**（出边表）和**逆邻接表**（入边表）

## 三、图的遍历与连通性

**图的遍历：**从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次。

**辅助数组`visited[]`：**为了避免重复访问，可设置一个标志顶点是否被访问过的辅助数组

- 初始状态为$0$，在图的遍历过程中，一旦某一个顶点$i$被访问，就立即让`visited[i] = 1`，防止它被多次访问。

### 深度优先搜索（DFS, Depth First Search）

```cpp
class Graph;

void DFS(Graph& G, const T& v){
    int loc, n = G.NumberOfVertices();
    bool *visited = new bool[n];
    for(int i = 0; i < n; i++){
        visited[i] = false;
    }
    loc = G.getVertexPos(v);
    DFS(G, loc, visited);
    delete []visited;
}

template<class T>
void DFS(Graph& G, int v, bool visited[]){
    cout << v << "\n";
    visited[v] = true;
    int w = G.getFirstNeighbor(v);
    while(w != -1){
        if(!visited[w]) DFS(G, w, visited);
        w = G.getNextNeighbor(w, v);
    }
}
```

### 广度优先搜索（BFS, Breadth First Search）

```cpp
void BFS(Graph& G, const T&v){
    int loc, n = G.NumberOfVertices();
    bool *visited = new bool[n];
    for(int i = 0; i < n; i++){
        visited[i] = false;
    }
    loc = G.getVertexPos(v);
    deque que;
    que.Enque(loc);
    cout << loc << "\n";
    visited[loc] = true;
    while(!que.Empty()){
        loc = que.Deque();
        next = G.getFirstNeighbor(loc);
        while(next != -1){
            if(!visited[next]){
               que.Enque(next); 
               cout << loc << "\n";
    			visited[loc] = true;
            }
            next = G.getNextNeighbor(next, loc);
        }
    }
    delete []visited;
}
```

`visited`：需要保证重复结点不会**重复入队**，而不是重复访问。

### 连通分量（Connected component）

当无向图为非连通图时，需要从每一连通分量中的一个顶点出发进行遍历，求得无向图的所有顶点。所有连通分量的生成树组成了**非连通图的生成森林**。

## 四、最小生成树

## 五、最短路径

## 六、活动网络

