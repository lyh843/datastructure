# 第十章 多级索引结构

## 一、多级索引基础

### 1. 索引定义

**索引**是由整数域 $Z$ 映射到存储地址域 $D$ 的函数 $Y:Z \rightarrow D$，核心作用是快速定位数据记录的存储位置。

### 2. 多级索引的必要性

当数据量极大时，一级索引表过大无法全部载入内存，需分批读取外存，效率低下。通过建立 “索引的索引”（二级索引、三级索引等），形成多级索引结构，其中高层索引可常驻内存，减少外存访问次数。

### 3. 多级索引的结构本质

* 形成**m 叉树**（m 路搜索树），分支结点对应**索引块**，叶结点对应数据记录的**索引项**（**最大关键码** + 存储地址）。

* 分为**静态结构**（初始创建后定型）和**动态结构**（随数据增删调整，保持搜索效率）。

### 4. m 路搜索树的递归定义

* 要么是空树，要么满足：


  * 根最多有 $m$ 棵子树，结构为 $(n, P_0, K_1, P_1, K_2, P_2, \cdots, K_n, P_n)$，其中 $K_i < K_{i + 1}$，$0 \leq i \leq n < m$

  * 子树 P₀中所有关键码 \<K₁，子树 Pᵢ（0\<i\<n）中关键码介于 Kᵢ和 Kᵢ₊₁之间，子树 Pₙ中所有关键码> Kₙ。

  * 所有子树均为 m 路搜索树。

## 二、B 树（平衡 m 路搜索树）

### 1. m 阶 B 树的定义

满足以下性质的平衡 m 路搜索树：

1. 根结点至少有 2 个子女，非根结点至少有⌈m/2⌉个子女（下限）。

2. 所有结点最多有 m 个子女（上限）。

3. 结点结构：(P₀, K₁, P₁, K₂, P₂, …, Kₙ, Pₙ)，其中 Pᵢ是子树指针，Kᵢ是关键码，且子树 Pᵢ中关键码范围符合 m 路搜索树规则。

4. 所有叶子结点位于同一层。

5. 每个非失败结点的关键码个数 n 满足：⌈m/2⌉ - 1 ≤ n ≤ m - 1。

### 2. B 树的插入操作

#### （1）插入规则



* 插入起点：叶结点。

* 正常情况：插入后关键码个数≤m-1，直接完成。

* 溢出处理：插入后关键码个数 > m-1，需**结点分裂**，分裂可能递归至根结点（导致树高 + 1）。

#### （2）分裂流程

以 m=3（3 阶 B 树）为例：



1. 溢出结点（含 n=m 个关键码）中间位置的关键码上移至父结点。

2. 原结点分裂为两个新结点，分别包含中间关键码左侧和右侧的关键码。

#### （3）插入示例

从空树建立 3 阶 B 树，依次插入 53、75、139、49、145、36、101，过程中需多次分裂结点，最终形成平衡结构。

### 3. B 树的删除操作

#### （1）删除规则



* 非叶结点删除：用该关键码的**前驱**（比它小的最大关键码）或**后继**（比它大的最小关键码）替换，转化为叶结点删除。

* 叶结点删除：

1. 删除后关键码个数≥⌈m/2⌉ - 1：直接完成。

2. 删除后关键码个数 <⌈m/2⌉ - 1：优先向兄弟结点 “借” 关键码；无兄弟可借时，与兄弟结点**合并**（可能递归至根结点，导致树高 - 1）。

#### （2）删除场景



1. 根结点且删除前 n≥2：直接删除。

2. 非根结点且删除前 n≥⌈m/2⌉：直接删除。

3. 需借关键码：父结点中对应关键码下移，兄弟结点中最小 / 最大关键码上移。

4. 需合并结点：将兄弟结点所有关键码并入当前结点，父结点中对应关键码删除，触发父结点调整。

#### （3）删除示例

3 阶 B 树中依次删除 50、40，过程包括前驱替换、结点合并、父结点调整，最终保持平衡。

## 三、B + 树（B 树的变种）

### 1. m 阶 B + 树的定义

#### （1）核心差异（与 B 树对比）



* 所有关键码仅存于叶结点，非叶结点的关键码是子树最大 / 最小关键码的复写（仅作索引引导）。

* 叶结点包含全部关键码及数据地址，且叶结点按关键码有序链接（支持顺序遍历）。

#### （2）结构性质



1. 每个结点最多有 m 棵子树。

2. 根结点最少有 1 棵子树，非根结点至少有⌈m/2⌉棵子树。

3. 有 n 棵子树的结点有 n 个关键码。

4. 所有叶结点在同一层，有序链接。

5. 非叶结点仅作为索引，不存储数据。

### 2. B + 树的插入操作



* 插入起点：叶结点。

* 正常情况：插入后关键码个数≤m，直接完成。

* 溢出处理：叶结点分裂为两个结点（关键码个数分别为⌈(m+1)/2⌉和⌊(m+1)/2⌋），父结点新增分裂后两个结点的最大关键码及地址。

* 根结点分裂：创建新根，树高 + 1。

### 3. B + 树的删除操作



* 删除起点：叶结点。

* 正常情况：删除后关键码个数≥⌈m/2⌉，直接完成（上层复写关键码可保留）。

* 不足处理：

1. 兄弟结点有多余关键码：兄弟结点最左 / 右关键码移入当前结点，更新上层引导关键码。

2. 兄弟结点无多余关键码：合并当前结点与兄弟结点，父结点对应引导关键码删除，可能触发父结点调整 / 合并（根结点合并会导致树高 - 1）。

## 四、B 树与 B + 树的核心对比



| 特性           | B 树                   | B + 树                              |
| -------------- | ---------------------- | ----------------------------------- |
| 关键码存储位置 | 所有结点均存储         | 仅叶结点存储（非叶结点为复写）      |
| 数据存储位置   | 所有结点均存储 data    | 仅叶结点存储 data                   |
| 查找效率       | 靠近根的关键码查找更快 | 所有关键码查找路径长度一致（根→叶） |
| 结点存储密度   | 较低（含 data）        | 较高（仅存关键码和指针）            |
| 树高           | 相对较高               | 相对较低                            |
| 支持操作       | 随机查找               | 随机查找 + 顺序查找（叶结点链接）   |
| 实际应用场景   | 数据库索引（少量场景） | 文件系统、数据库索引（主流）        |

## 五、总结



1. 多级索引的核心是通过 m 路搜索树减少外存访问次数，B 树和 B + 树是平衡化的动态索引结构。

2. B 树的优势是部分关键码查找路径短，B + 树的优势是存储密度高、树高更矮、支持顺序遍历，实际应用中性能更优。

3. 插入 / 删除操作的核心目标是维持树的平衡性，确保查找效率稳定（时间复杂度 O (logₘn)）。

> （注：文档部分内容可能由 AI 生成）