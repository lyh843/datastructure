# 第七章——搜索结构

## 一、静态搜索结构

**搜索：**在数据集合中寻找满足某种条件的数据对象

**搜索结构：**用于搜索的数据集合，由同一数据类型的对象组成

**搜索表：**

- **静态搜索表：**搜索结构在插入和删除等操作的前后不发生改变
- **动态搜索表：**为保持较高的搜索效率，搜索结构在插入和删除等操作的前后将自动进行调整，结构可能发生变化

### 静态搜索表

#### 顺序搜索（Sequential Search）

顺序搜索主要用于在线性表中搜索，从表的先端开始搜索，直至找到或检测完成。

**监视哨：**将尾部的空节点赋值为目标值。

#### 二分搜索

搜索表需要是有序的。

## 二、二叉搜索树

### 定义

二叉搜索树是一棵空树，或者是具有下列性质的二叉树：

- 每个结点都有一个座位搜索依据的关键码，所有结点的关键码互不相同
- 左子树（如果非空）上所有结点的关键码都小于根节点的关键码
- 右子树（如果非空）上所有结点的关键码都大于根节点的关键码
- 左子树和右子树也是二叉搜索树

如果进行中序遍历，可以实现按从小到大的顺序将各行的关键码排列起来

### 搜索算法

#### 步骤

1. 如果根指针为`NULL`，则搜索不成功；否则给定值`x`与根结点的关键码进行比较：

   - 若给定值等于根结点关键码，

     搜索成功，返回搜索成功信息并报告搜索到的节点。

   - 若给定值小于根结点的关键码，

     继续递归搜索根结点的左子树

   - 否则，

     递归搜索根结点的右子树

#### 代码实现

```cpp
// 递归实现
template<class E, class K>
Search(const K x, BSTNode<E, K>* ptr){
    if(ptr == nullptr) return nullptr;
    else if(x < ptr->data.key) return Search(x, ptr->left);
    else if(x > ptr->data.key) return Search(x, ptr->right);
    else return ptr;
};

// 非递归实现
template<class E, class K>
Search(const K x, BSTNode<E, K>* ptr){
	if(ptr == nullptr) return nullptr;
    while(ptr != nullptr){
        if(x < ptr->data.key) ptr = ptr->left;
        else if(x > ptr->data.key) ptr = ptr->right;
        else return ptr;
    }
    return ptr;
};
```

### 插入算法

### 步骤

在二叉搜素树中插入一个新元素时，必须先检查这个元素是否存在于树中。

在插入前，前

### 删除算法

## 三、AVL树

### 定义

一棵`AVL`树是空树或者是具有以下性质的二叉搜索树：它的左子树和右子树都是`AVL`树，且左子树和右子树的**高度之差的绝对值不超过1**

#### 结点的平衡因子（balance factor）

每个结点附加一个数字，给出该结点**右子树的高度减去左子树的高度**所得的高度差。这个数字即为结点的平衡因子`bf`

- `AVL`树任一结点平衡因子只能取`-1, 0, 1`

### 平衡化旋转

如果在一棵平衡的二叉搜索树中插入一个新结点，造成了不平衡。此时必须调整数的结构，使之平衡化。

**类型：**

- **单旋转**（左旋和右旋）
- **双旋转**（左平衡和右平衡）

#### 步骤

每插入一个新结点时，`AVL`树中相关结点的平衡状态会发生改变。因此，插入一个新节点后：

- 从**插入位置沿通过根的路径回溯**，检查各节点的平衡因子
- 如果某一节点发现高度不平衡，停止回溯，从不平衡的结点起，沿刚才回溯的路径取直接下两层的节点。
  - 如果三个结点处于**一条直线上**，采用单旋转进行平衡化。
  - 如果三个结点处于**一条折线上**，则采用双旋转进行平衡化。

#### 左单旋转（Rotate Left）

在结点$A$的**右子女的右子树**$E$中插入新结点，使得$A$的`bf == 2`，则进行左单旋转。

#### 右单旋转（Rotate Right）

在结点$A$的**左子女的左子树**$D$中插入新结点，使得$A$的`bf == -2`，则进行右单旋转。

#### 先右后左双旋转（Rotation Right Left）

在结点$A$的**右子女的左子树**中插入新结点，使得$A$的`bf == 2`，则对右子女进行右单旋转，对自己进行左单旋转。

#### 先左后右双旋转（Rotation Left Right）

在结点$A$的**左子女的右子树**中插入新结点，使得$A$的`bf == -2`，则对左子女进行左单旋转，对自己进行右单旋转。

### AVL树的插入

在插入新结点后，需从插入结点沿通向根的路径向上回溯，如果发现有不平衡的结点，需从这个结点出发，使用平衡旋转方法进行平衡化处理。

#### 三种情况

设新结点$p$的平衡因子为$0$，其父节点为$pr$。

- **结点pr的平衡因子为0**：说明是在$pr$的较矮子树上插入了新结点，此时不需做平衡化处理，返回主程序。子树的高度不变。
- **结点pr的平衡因子的绝对值|bf| = 1**：说明插入前$pr$的平衡因子是$0$，插入新结点后，以$pr$为根的子树不需要平衡化旋转。但该子树高度增加，需从结点$pr$向根方向回溯，继续考察结点$pr$双亲的平衡状态
- **结点pr的平衡因子的绝对值|bf| = 2**：说明新结点在较高的子树上插入，造成了不平衡，需要做平衡化旋转。

**例子：**插入关键码序列为$\{16, 3, 7, 11, 9, 26, 18, 14, 15\}$

### AVL树的删除

1. 如果被删结点$x$**最多只有一个子女**：
   - 将结点$x$从树中删去
   - 把$x$的双亲中原本指向$x$的指针指向这个子女结点，如果没有则`nullptr`
   - 将原来以结点$x$为根的子树的高度减$1$
2. 如果被删结点$x$有两个子女
   - 搜索$x$在中序次序下的直接前驱$y$
   - 把结点$y$的内容传送给$x$，问题转化为删除结点$y$
   - $y$最多有一个左子女（不存在右子女），可以采用方法$1$进行删除

- 必须沿结点$x$通向根的路径反向追踪高度的变化对路径上各个顶点的影响

  用一个`bool shorter`来指明子树高度是否被缩短。在每个结点上要做的操作取决于`shorter`的值和结点的`bf`，有时还要依赖子女的`bf`。

  布尔变量`shorter`的值初始化为`True`。然后对于从$x$的双亲到根的路径上的各个结点$p$， 在`shorter`保持为`True`时执行下面操作。如果`shorter`变成`False`，算法终止。

  1. 当前结点$p$的`bf == 0`，如果它的左子树或右子树被缩短，则它的`bf`改为$1$或$-1$，同时`shorter`置为`False`

  2. 结点$p$的`bf != 0`，且**较高的子树被缩短**。则$p$的`bf`改为$0$，同时`shorter`置为`True`

  3. 结点$p$的`bf != 0`，且**较矮的子树被缩短**，则$p$发生不平衡，需要平衡化旋转。

     令$p$的较高子树的根为$q$，根据$q$的`bf`，有如下三种平衡化操作：

     - 如果`q.bf == 0`，执行一个单旋转来恢复结点$p$的平衡，置`shorter`为`False`。无需检查上层节点的平衡因子。
     - 如果`q.bf == p.bf`，则执行一个单旋转来恢复平衡，结点$p$和$q$的`bf`均改为$0$，同时置`shorter`为`True`。还要继续检查上层结点的平衡因子。
     - 如果`q.bf != p.bf`，则执行一个双旋转来恢复平衡。新根结点的`bf`置为`0`，其他结点的`bf`相应处理，同时置`shorter`为`True`。还要继续检查上层结点的平衡因子。

